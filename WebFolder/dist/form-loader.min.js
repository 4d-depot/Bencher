/*! generated @at: 2021-04-16T13:09:14.361Z */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/$lib/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./datasources/form-loader.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./datasources/form-loader.js":
/*!************************************!*\
  !*** ./datasources/form-loader.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable no-await-in-loop, class-methods-use-this */

(() => {
	function Deferred() {
		// update 062115 for typeof
		if (typeof (Promise) !== 'undefined' && Promise.defer) {
			// need import of Promise.jsm for example: Cu.import('resource:/gree/modules/Promise.jsm');
			return Promise.defer();
		} if (typeof (PromiseUtils) !== 'undefined' && window.PromiseUtils.defer) {
			// need import of PromiseUtils.jsm for example: Cu.import('resource:/gree/modules/PromiseUtils.jsm');
			return window.PromiseUtils.defer();
		}
		/* A method to resolve the associated Promise with the value passed.
       * If the promise is already settled it does nothing.
       *
       * @param {anything} value : This value is used to resolve the promise
       * If the value is a Promise then the associated promise assumes the state
       * of Promise passed as value.
       */
		this.resolve = null;

		/* A method to reject the assocaited Promise with the value passed.
       * If the promise is already settled it does nothing.
       *
       * @param {anything} reason: The reason for the rejection of the Promise.
       * Generally its an Error object. If however a Promise is passed, then the Promise
       * itself will be the reason for rejection no matter the state of the Promise.
       */
		this.reject = null;

		/* A newly created Promise object.
       * Initially in pending state.
       */
		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);

	}

	function checkStyleOrScript(type) {
		return (path) => {
			return type === 'script'
				? document.querySelector(`script[src="${path}"]`)
				: document.querySelector(`link[rel="stylesheet"][href="${path}"]`);
		};
	}

	function loadStyleOrScript(pathOrObj, type = 'script') {
		// Return the promess if it is loading
		if (pathOrObj && typeof pathOrObj === 'object' && pathOrObj.$p) {
			return pathOrObj.$p;
		}

		// get the path
		const path = typeof pathOrObj === 'string'
			? pathOrObj
			: pathOrObj.path;

		// get the check function
		const check = pathOrObj
			&& typeof pathOrObj === 'object'
			&& typeof pathOrObj.check === 'function'
			? pathOrObj.check
			: checkStyleOrScript(type);

		const $p = new Promise((resolve, reject) => {
			if (check(path)) {
				return resolve();
			}

			let tag;

			switch (type) {
				case 'script':
				// Create the script tag
					tag = document.createElement('script');
					tag.src = path;
					break;
				case 'style':
				// Create the style tag
					tag = document.createElement('link');
					tag.rel = 'stylesheet';
					tag.href = path;
					break;
				default:
					break;
			}

			if (!tag) {
				return reject(new Error('Unknown tag type'));
			}

			tag.onload = resolve;
			tag.onabort = reject;
			tag.oncancel = reject;
			tag.onerror = reject;
			document.head.appendChild(tag);

			return true;
		});

		// save the promess to the object
		if (pathOrObj && typeof pathOrObj === 'object') {
			pathOrObj.$p = $p;
		}

		return $p;
	}

	const scripts = [{
		path: '/$lib/vendor/jquery/dist/jquery.min.js',
		check: () => {
			return typeof jQuery !== 'undefined'
				|| (
					typeof $ !== 'undefined'
					&& typeof $.ajax === 'function'
				);
		},
	}, {
		path: '/$lib/vendor/jquery-ui/dist/jquery-ui.min.js',
		check: () => {
			return window.jQuery && typeof window.jQuery.ui !== 'undefined';
		},
	}, {
		path: '/$lib/vendor/formiojs/dist/formio.full.js',
		check: () => {
			return typeof Formio !== 'undefined';
		},
	}, {
		path: '/$lib/dist/bundle.min.js',
	}, {
		path: '/$lib/dist/builder.min.js',
	}];

	const styles = [{
		path: '/$lib/vendor/font-awesome/css/font-awesome.min.css',
	}, {
		path: '/$lib/vendor/formiojs/dist/formio.full.css',
	}, {
		path: '/$lib/vendor/jquery-ui/dist/jquery-ui.min.css',
	}, {
		path: '/$lib/builder/css/renderer.css',
	}];

	const ds$ = new Deferred();

	window.addEventListener('bundle:ready', async ({ data: ds }) => {
		ds$.resolve(ds);
	});

	class FormLoader extends HTMLElement {
		static get observedAttributes() {
			return ['data-theme', 'data-name'];
		}

		constructor() {
			super();
			this.ready$ = new Deferred();
		}

		async connectedCallback() {
			for (let i = 0; i < styles.length; i += 1) {
				await loadStyleOrScript(styles[i], 'style');
			}
			for (let i = 0; i < scripts.length; i += 1) {
				await loadStyleOrScript(scripts[i], 'script');
			}
			this.ready$.resolve();
		}

		attributeChangedCallback(name, oldVal, newVal) {
			if (!newVal || newVal === oldVal) {
				return false;
			}

			switch (name) {
				case 'data-name':
					return this.loadForm(newVal);
				case 'data-theme':
					return this.loadTheme(newVal);
				default:
					break;
			}

			return true;
		}

		async loadTheme(theme) {
			if (!theme) {
				return false;
			}

			loadStyleOrScript({
				path: `/$lib/dist/skins/${theme}.min.css`,
			}, 'style');

			this.classList.forEach((className) => {
				if(/^theme-/.test(className) && className !== `theme-${theme}`) {
					this.classList.remove(className);
				}
			});

			this.classList.add(`theme-${theme}`, 'main');

			return true;
		}

		async loadForm(name) {
			if (!name) {
				return false;
			}

			let namespace = this.getAttribute('data-namespace');
			if (namespace == null || namespace === '')
				namespace = '__default';

			await this.ready$.promise;

			const res = await window.fetch('/rest/$GETFORM', {
				method: 'POST',
				body: JSON.stringify({
					metadata: {
						title: name,
					},
				}),
				headers: {
					'Content-Type': 'application/json',
				},
			});

			const json = await res.json();

			const { metadata = {} } = json;
			const { datasources = [] } = metadata;

			if (Array.isArray(datasources)) {
				const ds = await ds$.promise;
				datasources.forEach((source) => {
					DataSource.create(source, ds, namespace);
				});
			}

			await window.Formio.createForm(this, json);
			DataSource.buildDependencies(namespace);
			DataSource.createRequestOptimization(namespace);
			await DataSource.computeInitialValues(namespace);

			return true;
		}
	}

	customElements.define('form-loader', FormLoader);
})();


/***/ })

/******/ });
//# sourceMappingURL=form-loader.min.js.map